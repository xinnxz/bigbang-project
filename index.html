<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>THE GENESIS ENGINE // Audio-Visual Core</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;500&display=swap" rel="stylesheet">

    <style>
      /* --- Cinematic UI Styles --- */
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        height: 100vh;
        font-family: "Roboto Mono", monospace;
        user-select: none;
      }

      #canvas-container {
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 0;
        cursor: none; /* Hide default cursor */
      }

      /* ===== CUSTOM CURSOR ===== */
      .custom-cursor {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        mix-blend-mode: difference;
      }
      
      .cursor-dot {
        width: 8px;
        height: 8px;
        background: #fff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.1s ease, background 0.2s ease;
      }
      
      .cursor-ring {
        width: 40px;
        height: 40px;
        border: 2px solid rgba(77, 166, 255, 0.8);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.15s ease-out;
      }
      
      .cursor-ring.active {
        transform: translate(-50%, -50%) scale(0.5);
        border-color: #ff3300;
        box-shadow: 0 0 20px #ff3300, 0 0 40px rgba(255, 51, 0, 0.5);
        background: rgba(255, 51, 0, 0.1);
      }
      
      .cursor-trail {
        position: fixed;
        pointer-events: none;
        width: 4px;
        height: 4px;
        background: rgba(77, 166, 255, 0.6);
        border-radius: 50%;
        z-index: 9998;
        animation: trail-fade 0.6s forwards;
      }
      
      @keyframes trail-fade {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(0); }
      }

      /* ===== LOADING SCREEN ===== */
      #loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        transition: opacity 0.8s ease, visibility 0.8s ease;
      }
      
      #loader.hidden {
        opacity: 0;
        visibility: hidden;
      }
      
      .loader-logo {
        font-family: 'Orbitron', sans-serif;
        font-size: 3rem;
        font-weight: 900;
        color: #fff;
        letter-spacing: 0.3em;
        position: relative;
        text-shadow: 0 0 30px rgba(77, 166, 255, 0.5);
      }
      
      .loader-logo::before,
      .loader-logo::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      
      .loader-logo::before {
        color: #0ff;
        animation: glitch-1 0.3s infinite linear alternate-reverse;
        clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
      }
      
      .loader-logo::after {
        color: #f0f;
        animation: glitch-2 0.3s infinite linear alternate-reverse;
        clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
      }
      
      @keyframes glitch-1 {
        0%, 100% { transform: translateX(0); }
        20% { transform: translateX(-3px); }
        40% { transform: translateX(3px); }
        60% { transform: translateX(-2px); }
        80% { transform: translateX(2px); }
      }
      
      @keyframes glitch-2 {
        0%, 100% { transform: translateX(0); }
        20% { transform: translateX(3px); }
        40% { transform: translateX(-3px); }
        60% { transform: translateX(2px); }
        80% { transform: translateX(-2px); }
      }
      
      .loader-subtitle {
        font-family: 'Roboto Mono', monospace;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.6);
        letter-spacing: 0.5em;
        margin-top: 20px;
        text-transform: uppercase;
      }
      
      .loader-bar-container {
        width: 300px;
        height: 2px;
        background: rgba(255, 255, 255, 0.1);
        margin-top: 40px;
        position: relative;
        overflow: hidden;
      }
      
      .loader-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4da6ff, #00ffff, #4da6ff);
        box-shadow: 0 0 20px rgba(77, 166, 255, 0.8);
        transition: width 0.3s ease;
      }
      
      .loader-status {
        font-family: 'Roboto Mono', monospace;
        font-size: 0.7rem;
        color: rgba(77, 166, 255, 0.8);
        margin-top: 15px;
        letter-spacing: 0.2em;
      }
      
      .loader-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        pointer-events: none;
      }
      
      .loader-particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: rgba(77, 166, 255, 0.6);
        border-radius: 50%;
        animation: float-up 3s infinite;
      }
      
      @keyframes float-up {
        0% { transform: translateY(100vh) scale(0); opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { transform: translateY(-100vh) scale(1); opacity: 0; }
      }

      /* ===== AUDIO VISUALIZER ===== */
      #audio-visualizer {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        width: 400px;
        height: 80px;
        z-index: 50;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      
      #audio-visualizer.active {
        opacity: 0.8;
      }
      
      /* ===== ENHANCED HUD ===== */
      #hud {
        position: fixed;
        top: 30px;
        right: 30px;
        font-family: 'Roboto Mono', monospace;
        font-size: 0.7rem;
        color: rgba(77, 166, 255, 0.8);
        text-align: right;
        z-index: 100;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      
      #hud.active {
        opacity: 1;
      }
      
      .hud-row {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-bottom: 8px;
        gap: 10px;
      }
      
      .hud-label {
        color: rgba(255, 255, 255, 0.4);
        letter-spacing: 0.15em;
        text-transform: uppercase;
        font-size: 0.6rem;
      }
      
      .hud-value {
        color: rgba(77, 166, 255, 1);
        font-weight: 500;
        min-width: 60px;
        text-align: right;
      }
      
      .hud-value.warning {
        color: #ffaa00;
      }
      
      .hud-value.critical {
        color: #ff3300;
        animation: hud-pulse 0.5s infinite alternate;
      }
      
      @keyframes hud-pulse {
        from { opacity: 0.7; }
        to { opacity: 1; }
      }
      
      .intensity-bar {
        width: 80px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }
      
      .intensity-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #4da6ff, #00ffff);
        border-radius: 2px;
        transition: width 0.1s ease, background 0.3s ease;
      }
      
      .intensity-fill.high {
        background: linear-gradient(90deg, #ffaa00, #ff6600);
      }
      
      .intensity-fill.critical {
        background: linear-gradient(90deg, #ff3300, #ff0066);
      }
      
      /* ===== STATE INDICATOR ===== */
      .state-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .state-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #4da6ff;
        box-shadow: 0 0 10px currentColor;
        transition: background 0.3s ease, box-shadow 0.3s ease;
      }
      
      .state-dot.void { background: #666; box-shadow: none; }
      .state-dot.singularity { 
        background: #ff3300; 
        box-shadow: 0 0 15px #ff3300;
        animation: state-pulse 0.2s infinite alternate;
      }
      .state-dot.ignition { 
        background: #ffffff; 
        box-shadow: 0 0 20px #ffffff;
      }
      .state-dot.galaxy { 
        background: #4da6ff; 
        box-shadow: 0 0 10px #4da6ff;
      }
      
      @keyframes state-pulse {
        from { transform: scale(1); }
        to { transform: scale(1.3); }
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 30px;
        box-sizing: border-box;
        color: rgba(255, 255, 255, 0.9);
        z-index: 10;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.4) 100%
        );
        /* NEW: subtle parallax motion */
        transition: transform 0.18s ease-out;
      }

      .header-ui {
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      h1 {
        margin: 0;
        font-size: 1.4rem;
        color: #4da6ff;
        text-shadow: 0 0 15px rgba(77, 166, 255, 0.5);
      }

      .stats {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-top: 5px;
      }

      .footer-ui {
        text-align: center;
        margin-bottom: 50px;
        pointer-events: auto; /* Allow clicking the mute button if we added one */
      }

      #status-message {
        font-size: 1.2rem;
        font-weight: bold;
        letter-spacing: 3px;
        padding: 15px 30px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.5);
        display: inline-block;
        transition: all 0.3s ease;
      }

      #audio-init {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border: 1px solid #4da6ff;
        padding: 20px;
        background: rgba(0, 0, 0, 0.8);
        cursor: pointer;
        pointer-events: auto;
        z-index: 20;
        text-align: center;
      }

      #audio-init:hover {
        background: #4da6ff;
        color: #000;
      }

      /* Dynamic UI colors */
      .state-void {
        color: #aaa;
        border-color: #aaa;
      }

      .state-singularity {
        color: #ff3300;
        border-color: #ff3300;
        box-shadow: 0 0 20px #ff3300;
        animation: pulse 0.1s infinite alternate;
      }

      .state-ignition {
        color: #ffffff;
        border-color: #ffffff;
        box-shadow: 0 0 50px #ffffff;
      }

      .state-galaxy {
        color: #4da6ff;
        border-color: #4da6ff;
      }

      @keyframes pulse {
        from {
          transform: scale(0.99);
        }
        to {
          transform: scale(1.01);
        }
      }
    </style>
  </head>

  <body>
    <!-- LOADING SCREEN -->
    <div id="loader">
      <div class="loader-particles" id="loader-particles"></div>
      <div class="loader-logo" data-text="GENESIS">GENESIS</div>
      <div class="loader-subtitle">AUDIO-VISUAL ENGINE</div>
      <div class="loader-bar-container">
        <div class="loader-bar" id="loader-bar"></div>
      </div>
      <div class="loader-status" id="loader-status">INITIALIZING QUANTUM MATRIX...</div>
    </div>

    <!-- CUSTOM CURSOR -->
    <div class="custom-cursor cursor-dot" id="cursor-dot"></div>
    <div class="custom-cursor cursor-ring" id="cursor-ring"></div>

    <div id="canvas-container"></div>

    <div id="audio-init">CLICK TO INITIALIZE AUDIO SYSTEMS</div>

    <div id="ui-overlay" style="display: none">
      <div class="header-ui">
        <h1>// THE GENESIS ENGINE</h1>
        <div class="stats">
          AUDIO: Real-time Synthesis Active<br />
          VISUALS: GPU Particle Physics
        </div>
      </div>
      <div class="footer-ui">
        <div id="status-message" class="state-void">
          SYSTEM IDLE. CLICK & HOLD TO COMPRESS.
        </div>
      </div>
    </div>

    <!-- AUDIO VISUALIZER -->
    <canvas id="audio-visualizer"></canvas>

    <!-- ENHANCED HUD -->
    <div id="hud">
      <div class="hud-row">
        <span class="hud-label">PARTICLES</span>
        <span class="hud-value" id="hud-particles">50,000</span>
      </div>
      <div class="hud-row">
        <span class="hud-label">FPS</span>
        <span class="hud-value" id="hud-fps">60</span>
      </div>
      <div class="hud-row">
        <span class="hud-label">STATE</span>
        <div class="state-indicator">
          <div class="state-dot void" id="state-dot"></div>
          <span class="hud-value" id="hud-state">VOID</span>
        </div>
      </div>
      <div class="hud-row">
        <span class="hud-label">INTENSITY</span>
        <div class="intensity-bar">
          <div class="intensity-fill" id="intensity-fill"></div>
        </div>
      </div>
    </div>

    <script
      async
      src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>

    <!-- LOADING & CURSOR CONTROLLER -->
    <script>
      // ==================================================================================
      // --- LOADING SCREEN CONTROLLER ---
      // ==================================================================================
      const LoaderController = {
        loader: null,
        bar: null,
        status: null,
        particles: null,
        progress: 0,
        
        init() {
          this.loader = document.getElementById('loader');
          this.bar = document.getElementById('loader-bar');
          this.status = document.getElementById('loader-status');
          this.particles = document.getElementById('loader-particles');
          
          // Create floating particles
          this.createParticles(30);
          
          // Simulate loading progress
          this.simulateProgress();
        },
        
        createParticles(count) {
          for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.className = 'loader-particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 3 + 's';
            particle.style.animationDuration = (2 + Math.random() * 2) + 's';
            this.particles.appendChild(particle);
          }
        },
        
        updateProgress(value, statusText) {
          this.progress = value;
          this.bar.style.width = value + '%';
          if (statusText) this.status.textContent = statusText;
        },
        
        simulateProgress() {
          const stages = [
            { progress: 20, text: 'LOADING PARTICLE SYSTEM...' },
            { progress: 40, text: 'INITIALIZING SHADERS...' },
            { progress: 60, text: 'PREPARING AUDIO ENGINE...' },
            { progress: 80, text: 'CONFIGURING POST-PROCESSING...' },
            { progress: 100, text: 'GENESIS READY' }
          ];
          
          stages.forEach((stage, i) => {
            setTimeout(() => {
              this.updateProgress(stage.progress, stage.text);
            }, (i + 1) * 400);
          });
        },
        
        hide() {
          setTimeout(() => {
            this.loader.classList.add('hidden');
          }, 300);
        }
      };
      
      // ==================================================================================
      // --- CUSTOM CURSOR CONTROLLER ---
      // ==================================================================================
      const CursorController = {
        dot: null,
        ring: null,
        mouseX: 0,
        mouseY: 0,
        ringX: 0,
        ringY: 0,
        isActive: false,
        trailPoints: [],
        
        init() {
          this.dot = document.getElementById('cursor-dot');
          this.ring = document.getElementById('cursor-ring');
          
          document.addEventListener('mousemove', (e) => this.onMouseMove(e));
          document.addEventListener('mousedown', () => this.onMouseDown());
          document.addEventListener('mouseup', () => this.onMouseUp());
          document.addEventListener('mouseleave', () => this.hide());
          document.addEventListener('mouseenter', () => this.show());
          
          this.animate();
        },
        
        onMouseMove(e) {
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;
          
          // Instant dot follow
          this.dot.style.left = this.mouseX + 'px';
          this.dot.style.top = this.mouseY + 'px';
          
          // Create trail particle
          if (Math.random() > 0.7) {
            this.createTrail(this.mouseX, this.mouseY);
          }
        },
        
        onMouseDown() {
          this.isActive = true;
          this.ring.classList.add('active');
        },
        
        onMouseUp() {
          this.isActive = false;
          this.ring.classList.remove('active');
        },
        
        hide() {
          this.dot.style.opacity = '0';
          this.ring.style.opacity = '0';
        },
        
        show() {
          this.dot.style.opacity = '1';
          this.ring.style.opacity = '1';
        },
        
        createTrail(x, y) {
          const trail = document.createElement('div');
          trail.className = 'cursor-trail';
          trail.style.left = x + 'px';
          trail.style.top = y + 'px';
          document.body.appendChild(trail);
          
          // Remove after animation
          setTimeout(() => trail.remove(), 600);
        },
        
        animate() {
          // Smooth ring follow with easing
          this.ringX += (this.mouseX - this.ringX) * 0.15;
          this.ringY += (this.mouseY - this.ringY) * 0.15;
          
          this.ring.style.left = this.ringX + 'px';
          this.ring.style.top = this.ringY + 'px';
          
          requestAnimationFrame(() => this.animate());
        }
      };
      
      // ==================================================================================
      // --- AUDIO VISUALIZER CONTROLLER ---
      // ==================================================================================
      const AudioVisualizer = {
        canvas: null,
        ctx: null,
        isActive: false,
        
        init() {
          this.canvas = document.getElementById('audio-visualizer');
          this.ctx = this.canvas.getContext('2d');
          this.resize();
          window.addEventListener('resize', () => this.resize());
        },
        
        resize() {
          this.canvas.width = 400;
          this.canvas.height = 80;
        },
        
        activate() {
          this.isActive = true;
          this.canvas.classList.add('active');
        },
        
        deactivate() {
          this.isActive = false;
          this.canvas.classList.remove('active');
        },
        
        draw(frequencyData, intensity = 0) {
          if (!this.isActive || !frequencyData) return;
          
          const { width, height } = this.canvas;
          this.ctx.clearRect(0, 0, width, height);
          
          // Number of bars to draw
          const barCount = 64;
          const barWidth = (width / barCount) - 1;
          const dataStep = Math.floor(frequencyData.length / barCount);
          
          for (let i = 0; i < barCount; i++) {
            const dataIndex = i * dataStep;
            const value = frequencyData[dataIndex] || 0;
            const barHeight = (value / 255) * height;
            
            // Calculate color based on frequency and intensity
            const hue = 200 + (i / barCount) * 60 + intensity * 30;
            const saturation = 70 + intensity * 30;
            const lightness = 40 + (value / 255) * 30;
            
            // Gradient effect
            const gradient = this.ctx.createLinearGradient(0, height, 0, height - barHeight);
            gradient.addColorStop(0, `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`);
            gradient.addColorStop(1, `hsla(${hue + 20}, ${saturation}%, ${lightness + 20}%, 0.4)`);
            
            this.ctx.fillStyle = gradient;
            this.ctx.fillRect(
              i * (barWidth + 1),
              height - barHeight,
              barWidth,
              barHeight
            );
            
            // Add glow on high values
            if (value > 180) {
              this.ctx.shadowBlur = 10;
              this.ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
            } else {
              this.ctx.shadowBlur = 0;
            }
          }
        }
      };
      
      // ==================================================================================
      // --- HUD CONTROLLER ---
      // ==================================================================================
      const HUDController = {
        hud: null,
        fpsEl: null,
        particlesEl: null,
        stateEl: null,
        stateDot: null,
        intensityFill: null,
        lastTime: performance.now(),
        frameCount: 0,
        fps: 60,
        
        init() {
          this.hud = document.getElementById('hud');
          this.fpsEl = document.getElementById('hud-fps');
          this.particlesEl = document.getElementById('hud-particles');
          this.stateEl = document.getElementById('hud-state');
          this.stateDot = document.getElementById('state-dot');
          this.intensityFill = document.getElementById('intensity-fill');
        },
        
        activate() {
          this.hud.classList.add('active');
        },
        
        updateFPS() {
          this.frameCount++;
          const now = performance.now();
          const delta = now - this.lastTime;
          
          if (delta >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / delta);
            this.frameCount = 0;
            this.lastTime = now;
            
            this.fpsEl.textContent = this.fps;
            this.fpsEl.className = 'hud-value';
            if (this.fps < 30) {
              this.fpsEl.classList.add('critical');
            } else if (this.fps < 50) {
              this.fpsEl.classList.add('warning');
            }
          }
        },
        
        updateState(stateName) {
          this.stateEl.textContent = stateName;
          this.stateDot.className = 'state-dot ' + stateName.toLowerCase();
        },
        
        updateIntensity(value) {
          const percent = Math.min(value * 100, 100);
          this.intensityFill.style.width = percent + '%';
          
          this.intensityFill.className = 'intensity-fill';
          if (value > 0.8) {
            this.intensityFill.classList.add('critical');
          } else if (value > 0.5) {
            this.intensityFill.classList.add('high');
          }
        }
      };
      
      // Initialize on DOM ready
      document.addEventListener('DOMContentLoaded', () => {
        LoaderController.init();
        CursorController.init();
        AudioVisualizer.init();
        HUDController.init();
      });
    </script>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
      
      // Custom Chromatic Aberration Shader
      const ChromaticAberrationShader = {
        uniforms: {
          tDiffuse: { value: null },
          amount: { value: 0.003 },
          angle: { value: 0.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float amount;
          uniform float angle;
          varying vec2 vUv;
          void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
          }
        `
      };
      
      // Custom Vignette Shader
      const VignetteShader = {
        uniforms: {
          tDiffuse: { value: null },
          offset: { value: 1.0 },
          darkness: { value: 1.2 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float offset;
          uniform float darkness;
          varying vec2 vUv;
          void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            vec2 uv = (vUv - 0.5) * 2.0;
            float vignetteAmount = 1.0 - dot(uv, uv) * darkness;
            vignetteAmount = clamp(vignetteAmount, 0.0, 1.0);
            vignetteAmount = smoothstep(0.0, offset, vignetteAmount);
            gl_FragColor = vec4(texel.rgb * vignetteAmount, texel.a);
          }
        `
      };

      // ==================================================================================
      // --- AUDIO ENGINE (WEB AUDIO API) ---
      // ==================================================================================
      const AudioEngine = {
        ctx: null,
        masterGain: null,
        oscillators: [],
        riserOsc: null,
        riserGain: null,
        droneOsc: null,

        init: function () {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.ctx = new AudioContext();
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = 0.4; // Master volume
          this.masterGain.connect(this.ctx.destination);
          this.startDrone();
        },

        startDrone: function () {
          // Deep space drone
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();

          osc.type = "sawtooth";
          osc.frequency.value = 40; // Low rumble
          filter.type = "lowpass";
          filter.frequency.value = 120;

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.masterGain);

          gain.gain.value = 0.1;
          osc.start();
          this.droneOsc = { osc, gain, filter }; // Store to modulate later
        },

        startRiser: function () {
          // The sound of compression
          if (this.riserOsc) this.stopRiser();

          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();

          osc.type = "triangle";
          osc.frequency.value = 50;

          // LFO for "wobble"
          const lfo = this.ctx.createOscillator();
          lfo.frequency.value = 10;
          const lfoGain = this.ctx.createGain();
          lfoGain.gain.value = 20;
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);

          osc.connect(gain);
          gain.connect(this.masterGain);

          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);

          osc.start();
          lfo.start();

          this.riserOsc = osc;
          this.riserGain = gain;
          this.riserLfo = lfo;
        },

        modulateRiser: function (intensity) {
          // Pitch goes up as we hold
          if (this.riserOsc) {
            const freq = 50 + intensity * 800;
            this.riserOsc.frequency.setTargetAtTime(
              freq,
              this.ctx.currentTime,
              0.1
            );
            this.riserLfo.frequency.value = 10 + intensity * 30;
          }
        },

        stopRiser: function () {
          if (this.riserOsc) {
            this.riserOsc.stop();
            this.riserLfo.stop();
            this.riserOsc = null;
          }
        },

        triggerExplosion: function () {
          this.stopRiser();

          // 1. White Noise Burst (The Crack)
          const bufferSize = this.ctx.sampleRate * 2; // 2 seconds
          const buffer = this.ctx.createBuffer(
            1,
            bufferSize,
            this.ctx.sampleRate
          );
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }
          const noise = this.ctx.createBufferSource();
          noise.buffer = buffer;
          const noiseFilter = this.ctx.createBiquadFilter();
          noiseFilter.type = "lowpass";
          noiseFilter.frequency.value = 1000;
          const noiseGain = this.ctx.createGain();
          noiseGain.gain.setValueAtTime(1, this.ctx.currentTime);
          noiseGain.gain.exponentialRampToValueAtTime(
            0.01,
            this.ctx.currentTime + 1.5
          );

          noise.connect(noiseFilter);
          noiseFilter.connect(noiseGain);
          noiseGain.connect(this.masterGain);
          noise.start();

          // 2. Sub-Bass Kick (The Thump)
          const kick = this.ctx.createOscillator();
          const kickGain = this.ctx.createGain();
          kick.frequency.setValueAtTime(150, this.ctx.currentTime);
          kick.frequency.exponentialRampToValueAtTime(
            30,
            this.ctx.currentTime + 0.5
          );
          kickGain.gain.setValueAtTime(1, this.ctx.currentTime);
          kickGain.gain.exponentialRampToValueAtTime(
            0.01,
            this.ctx.currentTime + 1.5
          );

          kick.connect(kickGain);
          kickGain.connect(this.masterGain);
          kick.start();
          kick.stop(this.ctx.currentTime + 1.5);
        },

        startGalaxyAmbience: function () {
          // Ethereal chord
          const freqs = [261.63, 329.63, 392.0, 523.25]; // C Major
          freqs.forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const pan = this.ctx.createStereoPanner();

            osc.type = "sine";
            osc.frequency.value = f;

            pan.pan.value = -0.5 + Math.random(); // Spread sound

            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 2); // Slow fade in

            osc.connect(pan);
            pan.connect(gain);
            gain.connect(this.masterGain);

            osc.start();
            this.oscillators.push({ osc, gain });
          });
        },

        resetGalaxy: function () {
          this.oscillators.forEach((o) => {
            o.gain.gain.exponentialRampToValueAtTime(
              0.001,
              this.ctx.currentTime + 1
            );
            o.osc.stop(this.ctx.currentTime + 1);
          });
          this.oscillators = [];
        },
      };

      // ==================================================================================
      // --- ADVANCED NEBULA SHADERS ---
      // ==================================================================================
      const _VS = `
            uniform float uTime;
            uniform float uIntensity;
            
            attribute float size;
            attribute vec3 customColor;
            
            varying vec3 vColor;
            varying float vDistance;
            varying float vSize;
            varying float vIntensity;
            
            void main() {
                vColor = customColor;
                vIntensity = uIntensity;
                
                // Add subtle vertex animation based on time
                vec3 pos = position;
                float wave = sin(pos.x * 0.05 + uTime) * cos(pos.z * 0.05 + uTime * 0.7);
                pos.y += wave * uIntensity * 2.0;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                vDistance = -mvPosition.z;
                
                // Dynamic size based on intensity and distance
                float dynamicSize = size * (1.0 + uIntensity * 0.5);
                vSize = dynamicSize;
                gl_PointSize = dynamicSize * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
      
      const _FS = `
            uniform vec3 color;
            uniform float uTime;
            uniform float uIntensity;
            
            varying vec3 vColor;
            varying float vDistance;
            varying float vSize;
            varying float vIntensity;
            
            // Simplex noise function for organic shapes
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                         -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy));
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                    + i.x + vec3(0.0, i1.x, 1.0));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                    dot(x12.zw,x12.zw)), 0.0);
                m = m*m;
                m = m*m;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                vec3 g;
                g.x = a0.x * x0.x + h.x * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
            
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float r = length(coord) * 2.0;
                
                // Organic nebula shape using noise
                float noiseVal = snoise(coord * 4.0 + uTime * 0.5) * 0.3;
                float organicRadius = r + noiseVal * (1.0 - r) * vIntensity;
                
                // Discard outside organic boundary
                if (organicRadius > 1.0) discard;
                
                // Multi-layer glow effect
                float innerGlow = exp(-organicRadius * organicRadius * 3.0);
                float outerGlow = exp(-r * r * 1.5) * 0.5;
                float glow = innerGlow + outerGlow;
                
                // Add sparkle effect
                float sparkle = snoise(coord * 20.0 + uTime * 2.0);
                sparkle = pow(max(sparkle, 0.0), 3.0) * 0.3 * vIntensity;
                
                // Distance fog
                float fogFactor = smoothstep(150.0, 20.0, vDistance) * 0.7 + 0.3;
                
                // Dynamic color enhancement
                vec3 enhancedColor = vColor;
                enhancedColor += vec3(0.1, 0.05, 0.15) * vIntensity; // Add purple tint during intensity
                enhancedColor += vec3(sparkle * 0.5); // Add sparkle brightness
                
                // Core brightness boost
                float coreBrightness = 1.0 + innerGlow * vIntensity * 2.0;
                
                float alpha = (glow + sparkle) * fogFactor;
                gl_FragColor = vec4(color * enhancedColor * coreBrightness * fogFactor, alpha);
            }
        `;

      const CONFIG = {
        PARTICLE_COUNT: 50000,
        BASE_SIZE: 0.6,
        GALAXY_RADIUS: 60,
        GALAXY_ARMS: 5,
        GALAXY_SPIN: 3.5,
        IGNITION_FORCE: 150.0,
        DRAG_COEFFICIENT: 0.965,
        GRAVITY_STRENGTH: 0.04,
      };

      const STATES = { VOID: 0, SINGULARITY: 1, IGNITION: 2, GALAXY: 3 };

      let currentState = STATES.VOID;
      let scene, camera, renderer, composer, bloomPass;
      let particleSystem, geometry, material;
      let galaxyTargets = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
      let ignitionTime = 0;
      const velocities = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
      const statusMsg = document.getElementById("status-message");

      // NEW: references & mouse state
      const uiOverlay = document.getElementById("ui-overlay");
      const audioInitPanel = document.getElementById("audio-init");
      const canvasContainer = document.getElementById("canvas-container");
      const mouse = { x: 0, y: 0 }; // normalized -1..1

      // --- INITIALIZATION FLOW ---
      document
        .getElementById("audio-init")
        .addEventListener("click", function () {
          // Hide loading screen
          LoaderController.hide();
          
          // Activate HUD and Visualizer
          HUDController.activate();
          AudioVisualizer.activate();
          
          AudioEngine.init();
          this.style.display = "none";
          document.getElementById("ui-overlay").style.display = "flex";
          initThree();
          animate();
        });

      function initThree() {
        const container = document.getElementById("canvas-container");
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.005);
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 20, 120);

        renderer = new THREE.WebGLRenderer({ antialias: false, depth: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.0;
        container.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0.1;
        bloomPass.strength = 2.5;
        bloomPass.radius = 0.55;
        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);
        
        // Chromatic Aberration - subtle RGB split for cinematic look
        const chromaticPass = new ShaderPass(ChromaticAberrationShader);
        chromaticPass.uniforms['amount'].value = 0.002;
        composer.addPass(chromaticPass);
        
        // Film Grain - adds texture and analog feel
        const filmPass = new FilmPass(0.25, false);
        composer.addPass(filmPass);
        
        // Vignette - darkens edges, focuses attention on center
        const vignettePass = new ShaderPass(VignetteShader);
        vignettePass.uniforms['offset'].value = 0.95;
        vignettePass.uniforms['darkness'].value = 0.5;
        composer.addPass(vignettePass);
        
        // Store passes for dynamic control
        window.postFX = { chromaticPass, filmPass, vignettePass, bloomPass };

        createParticles();
        generateGalaxyTargets();

        window.addEventListener("resize", onWindowResize);
        document.addEventListener("mousedown", onMouseDown);
        document.addEventListener("mouseup", onMouseUp);

        // NEW: mouse tracking
        document.addEventListener("pointermove", onPointerMove);
      }

      function createParticles() {
        geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
        const colors = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
        const sizes = new Float32Array(CONFIG.PARTICLE_COUNT);
        const colorObj = new THREE.Color();

        for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          const r = Math.random() * 200 + 50;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          positions[i3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.1;
          positions[i3 + 2] = r * Math.cos(phi);
          velocities[i3] = (Math.random() - 0.5) * 0.1;
          velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
          velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
          colorObj.setHSL(
            0.6 + Math.random() * 0.2,
            0.5,
            0.3 + Math.random() * 0.4
          );
          colors[i3] = colorObj.r;
          colors[i3 + 1] = colorObj.g;
          colors[i3 + 2] = colorObj.b;
          sizes[i] = CONFIG.BASE_SIZE * (Math.random() * 0.8 + 0.2);
        }
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute(
          "customColor",
          new THREE.BufferAttribute(colors, 3)
        );
        geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
        material = new THREE.ShaderMaterial({
          uniforms: { 
            color: { value: new THREE.Color(0xffffff) },
            uTime: { value: 0.0 },
            uIntensity: { value: 0.0 }
          },
          vertexShader: _VS,
          fragmentShader: _FS,
          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
          vertexColors: true,
        });
        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
      }

      function generateGalaxyTargets() {
        for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          const armIndex = i % CONFIG.GALAXY_ARMS;
          const radius = Math.pow(Math.random(), 1.5) * CONFIG.GALAXY_RADIUS;
          const spinOffset = radius * CONFIG.GALAXY_SPIN;
          const armAngleOffset = (armIndex / CONFIG.GALAXY_ARMS) * Math.PI * 2;
          const finalAngle = spinOffset + armAngleOffset;
          galaxyTargets[i3] =
            Math.cos(finalAngle) * radius + (Math.random() - 0.5) * 1.5;
          const heightThickness = 1.0 - radius / CONFIG.GALAXY_RADIUS;
          galaxyTargets[i3 + 1] =
            (Math.random() - 0.5) * (8 * heightThickness * heightThickness);
          galaxyTargets[i3 + 2] =
            Math.sin(finalAngle) * radius + (Math.random() - 0.5) * 1.5;
        }
      }

      // --- INTERACTIONS ---
      function onMouseDown(e) {
        if (e.button !== 0) return;
        if (currentState === STATES.VOID || currentState === STATES.GALAXY) {
          currentState = STATES.SINGULARITY;
          updateUI(STATES.SINGULARITY);
          bloomPass.strength = 4.0;
          bloomPass.radius = 0.1;
          // Audio
          AudioEngine.resetGalaxy();
          AudioEngine.startRiser();
        }
      }

      function onMouseUp(e) {
        if (e.button !== 0) return;
        if (currentState === STATES.SINGULARITY) {
          triggerIgnition();
        }
      }

      // NEW: pointer move handler
      function onPointerMove(e) {
        const nx = (e.clientX / window.innerWidth) * 2 - 1;
        const ny = (e.clientY / window.innerHeight) * 2 - 1;
        mouse.x = nx;
        mouse.y = ny;

        // Parallax on UI HUD
        if (uiOverlay) {
          const uiOffsetX = nx * 12; // px
          const uiOffsetY = ny * 8; // px
          uiOverlay.style.transform = `translate3d(${uiOffsetX}px, ${uiOffsetY}px, 0)`;
        }
      }

      function triggerIgnition() {
        currentState = STATES.IGNITION;
        updateUI(STATES.IGNITION);
        ignitionTime = Date.now();
        bloomPass.strength = 8.0;
        bloomPass.radius = 1.5;

        // Audio
        AudioEngine.triggerExplosion();

        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
          const i3 = i * 3;
          positions[i3] = (Math.random() - 0.5) * 0.1;
          positions[i3 + 1] = (Math.random() - 0.5) * 0.1;
          positions[i3 + 2] = (Math.random() - 0.5) * 0.1;
          let vx = Math.random() - 0.5;
          let vy = (Math.random() - 0.5) * 0.3;
          let vz = Math.random() - 0.5;
          const len = Math.sqrt(vx * vx + vy * vy + vz * vz);
          const forceVariation = Math.random() * 0.8 + 0.2;
          velocities[i3] = (vx / len) * CONFIG.IGNITION_FORCE * forceVariation;
          velocities[i3 + 1] =
            (vy / len) * CONFIG.IGNITION_FORCE * forceVariation;
          velocities[i3 + 2] =
            (vz / len) * CONFIG.IGNITION_FORCE * forceVariation;
          colors[i3] = 1.0;
          colors[i3 + 1] = 1.0;
          colors[i3 + 2] = 1.0;
        }

        setTimeout(() => {
          if (currentState === STATES.IGNITION) {
            currentState = STATES.GALAXY;
            updateUI(STATES.GALAXY);
            bloomPass.strength = 2.0;
            bloomPass.radius = 0.6;
            AudioEngine.startGalaxyAmbience();
          }
        }, 4000);
      }

      function updateUI(state) {
        statusMsg.className = "";
        switch (state) {
          case STATES.SINGULARITY:
            statusMsg.innerText = "CRITICAL: COMPRESSING...";
            statusMsg.classList.add("state-singularity");
            break;
          case STATES.IGNITION:
            statusMsg.innerText = "EXPANSION DETECTED";
            statusMsg.classList.add("state-ignition");
            break;
          case STATES.GALAXY:
            statusMsg.innerText = "GALAXY STABLE";
            statusMsg.classList.add("state-galaxy");
            break;
          default:
            statusMsg.innerText = "SYSTEM IDLE";
            statusMsg.classList.add("state-void");
        }
      }

      // --- ANIMATION LOOP ---
      let shaderIntensity = 0.0;
      
      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.customColor.array;
        const colorObj = new THREE.Color();
        
        // Update shader uniforms
        material.uniforms.uTime.value = time;
        
        // Calculate target intensity based on state
        let targetIntensity = 0.0;
        if (currentState === STATES.SINGULARITY) {
          targetIntensity = 1.0;
        } else if (currentState === STATES.IGNITION) {
          targetIntensity = 1.5;
        } else if (currentState === STATES.GALAXY) {
          targetIntensity = 0.3;
        }
        
        // Smooth interpolation of intensity
        shaderIntensity += (targetIntensity - shaderIntensity) * 0.05;
        material.uniforms.uIntensity.value = shaderIntensity;
        
        // Update HUD
        HUDController.updateFPS();
        HUDController.updateIntensity(shaderIntensity);
        
        // Update state name in HUD
        const stateNames = ['VOID', 'SINGULARITY', 'IGNITION', 'GALAXY'];
        HUDController.updateState(stateNames[currentState]);
        
        // Draw audio visualizer (placeholder - would need real audio data)
        // For now, generate pseudo-random visualization based on state
        const fakeAudioData = new Uint8Array(64);
        for (let i = 0; i < 64; i++) {
          const baseValue = Math.sin(time * 2 + i * 0.2) * 50 + 50;
          const stateBoost = currentState === STATES.SINGULARITY ? 80 : 
                             currentState === STATES.IGNITION ? 150 :
                             currentState === STATES.GALAXY ? 40 : 20;
          fakeAudioData[i] = Math.min(255, baseValue + Math.random() * stateBoost);
        }
        AudioVisualizer.draw(fakeAudioData, shaderIntensity);

        if (currentState === STATES.SINGULARITY) {
          // Calculate average compression for audio modulation
          let totalDist = 0;

          for (let i = 0; i < CONFIG.PARTICLE_COUNT * 3; i += 3) {
            positions[i] *= 0.85;
            positions[i + 1] *= 0.85;
            positions[i + 2] *= 0.85;
            totalDist += Math.abs(positions[i]); // rough approximation

            colors[i] = Math.min(colors[i] + 0.05, 1.0);
            colors[i + 1] = Math.min(colors[i + 1] + 0.04, 0.9);
            colors[i + 2] = Math.min(colors[i + 2] + 0.02, 0.8);
          }
          camera.position.x += (Math.random() - 0.5) * 0.2;
          camera.position.y += (Math.random() - 0.5) * 0.2;

          // Modulate Audio Pitch based on tightness
          AudioEngine.modulateRiser(1.0 - Math.min(totalDist, 1.0));
        } else if (currentState === STATES.IGNITION) {
          for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            positions[i3] += velocities[i3] * 0.016;
            positions[i3 + 1] += velocities[i3 + 1] * 0.016;
            positions[i3 + 2] += velocities[i3 + 2] * 0.016;
            velocities[i3] *= CONFIG.DRAG_COEFFICIENT;
            velocities[i3 + 1] *= CONFIG.DRAG_COEFFICIENT;
            velocities[i3 + 2] *= CONFIG.DRAG_COEFFICIENT;

            const speed = Math.sqrt(
              velocities[i3] ** 2 + velocities[i3 + 2] ** 2
            );
            const normalizedSpeed = Math.min(speed / 5.0, 1.0);
            colorObj.setHSL(
              0.6 - normalizedSpeed * 0.5,
              0.8,
              0.2 + normalizedSpeed * 0.8
            );
            colors[i3] = colorObj.r;
            colors[i3 + 1] = colorObj.g;
            colors[i3 + 2] = colorObj.b;
          }
          bloomPass.strength = Math.max(2.0, bloomPass.strength * 0.95);
        } else if (currentState === STATES.GALAXY) {
          for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            let dx = galaxyTargets[i3] - positions[i3];
            let dy = galaxyTargets[i3 + 1] - positions[i3 + 1];
            let dz = galaxyTargets[i3 + 2] - positions[i3 + 2];
            velocities[i3] += dx * CONFIG.GRAVITY_STRENGTH * 0.01;
            velocities[i3 + 1] += dy * CONFIG.GRAVITY_STRENGTH * 0.01;
            velocities[i3 + 2] += dz * CONFIG.GRAVITY_STRENGTH * 0.01;
            velocities[i3] *= 0.92;
            velocities[i3 + 1] *= 0.92;
            velocities[i3 + 2] *= 0.92;
            positions[i3] += velocities[i3];
            positions[i3 + 1] += velocities[i3 + 1];
            positions[i3 + 2] += velocities[i3 + 2];

            const dist = Math.sqrt(positions[i3] ** 2 + positions[i3 + 2] ** 2);
            const distNorm = Math.min(dist / CONFIG.GALAXY_RADIUS, 1.0);
            colorObj.setHSL(0.6 + distNorm * 0.1, 0.6, 0.7 - distNorm * 0.4);
            colors[i3] = colorObj.r;
            colors[i3 + 1] = colorObj.g;
            colors[i3 + 2] = colorObj.b;
          }
        } else {
          particleSystem.rotation.y = time * 0.02;
        }

        if (currentState !== STATES.SINGULARITY)
          particleSystem.rotation.y += 0.0005;

        // NEW: particle parallax rotation based on mouse
        particleSystem.rotation.x +=
          (mouse.y * 0.4 - particleSystem.rotation.x) * 0.03;
        particleSystem.rotation.y +=
          (mouse.x * 0.6 - particleSystem.rotation.y) * 0.03;

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.customColor.needsUpdate = true;

        const camTime = time * 0.2;
        camera.position.x = Math.sin(camTime) * 30;
        camera.position.z = Math.cos(camTime * 0.7) * 120 + 20;

        // NEW: camera follows mouse slightly
        camera.position.x += mouse.x * 25;
        camera.position.y = 20 + mouse.y * -10;

        camera.lookAt(0, 0, 0);
        composer.render();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>
  </body>
</html>
